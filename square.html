<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Disegnare un Punto</title>
</head>

<body>
  <canvas id="myCanvas" width="800" height="800"></canvas>

  <script>
    // Ottieni il riferimento al canvas utilizzando JavaScript
    const canvas = document.getElementById("myCanvas");

    // Ottieni il contesto di rendering 2D
    const ctx = canvas.getContext("2d")
    const L = 100
    const CENTER = [150, 150]
    const [x0, y0] = CENTER

    const A = [x0 - L, y0 - L]
    const B = [x0 + L, y0 - L]
    const C = [x0 - L, y0 + L]
    const D = [x0 + L, y0 + L]

    const VERTICES = []
    VERTICES.push(A, B, C, D)

    const drawPoints = async function(figure, fill = 2) {
      let i = 0
      for (const point of figure) {
        const [x, y] = point
        ctx.fillRect(x, y, fill, fill)
        // console.log(`x:${x} - y:${y}`)

      }
    }

    /** 
     * no we have circle points and center,
     * we can draw a line foreach point of the circle passing for center,
     * in order to do this we must calculate the m of the lin:
     * 
     * 1) y-y0 = m(x-x0) => m = (x-x0)/y-y0
     * 
     * now we need q ( y = mx +q)
     * just resolve the 1 eq considering 1 x0 and y0 known
     * 
     * y-y0 = m*(x-x0)
     * y = m*x + (y0 - m*x0)
     * => q = y0-m*x0
     */
    const twoPointLine = async function(a, b) {

      let [x1, y1] = a
      let [x2, y2] = b

      if (x1 > x2) {
        [x1, x2] = [x2, x1];
        [y1, y2] = [y2, y1];
      }

      // calculating m having a and b
      let m = (y2 - y1) / (x2 - x1)
      // calculating q having m adn a or b
      const q = (y1 - m * x1)


      // set are faster than array and also we don't need duplicate values and we don't care about order
      const line = new Set()
      /** 
       *  let step = 1 / Math.abs(m) (below)
       * 
       * As m increases, the generated segment will be longer, so the larger m grows, 
       * the smaller the step with which I generate the x must be, otherwise we would have 
       * empty spaces between one point and another on the line. ques
       * 
       * To understand why using 1/|m| as a step during the creation of the line is important, 
       * let's consider the following situation:
       *
       * Imagine having a line with a very high slope, for example m = 10, and two points A and B:
       * - A(0, 0)
       * - B(1, 10)
       *
       * If we use a fixed step of 1 for x, we will get the following points on the line:
       * - x = 0, y = 0
       * - x = 1, y = 10
       *
       * However, between these two points, we will have a series of x positions that do not 
       * correspond to integer values. For example, if we consider x = 0.1, we get:
       * - x = 0.1, y = 1
       * And if we consider x = 0.2, we get:
       * - x = 0.2, y = 2
       *
       * Continuing this way, we see that many integer values of y are missed because we are 
       * advancing with steps of 1 on x, and the line has a very steep slope.
       *
       * If, on the other hand, we use a step of 1/|m| (in our example, 1/10), we get a higher 
       * density of points because we are considering smaller steps on x to capture finer details 
       * along the line. This helps to reduce the loss of points when the slope is high, improving 
       * the representation of the line on a discrete grid.
       * 
       * However, suing 1/|m| can lead to very large step when m is very samll, this can cause the loss of point as wellwe so we set a maximum 
       * limit of 1 for the step. This ensures that even for shallow slopes, the step remains within a 
       * reasonable range to maintain a visually coherent representation of the line. 
       */

      let step = 1 / Math.abs(m)

      // setting maximum value for the step to void too large steps
      if (step > 1) {
        step = 1;
      }

      /** 
       * when the step is too small whe tend to have infinite values
       * so we need an inferior limit
       */
      if (step < 0.1) {
        step = 0.1
      }
      if (!isFinite(m)) {
        if (y1 > y2)[y1, y2] = [y2, y1]
        for (y = y1; y < y2; y++) {
          line.add([x1, y])
        }
      } else {
        // generating line points
        for (let x = x1; x <= x2; x += step) {
          let y = m * x + q
          y = Math.round(y)
          line.add([Math.round(x), y])
        }

      }

      return line;
    }

    const rotationMatrix2D = async function(figure, center, theta, keepCenter = true) {
      const figure1 = []
      for (point of figure) {
        let [x, y] = point
        const [xc, yc] = center

        // getting point coordinates around the origin
        if (keepCenter)[x, y] = [x - xc, y - yc]


        // calculating nthe new point
        x1 = x * Math.cos(theta) - y * Math.sin(theta)
        y1 = x * Math.sin(theta) + y * Math.cos(theta)

        // traslating point around the original center
        if (keepCenter)[x1, y1] = [x1 + xc, y1 + yc]

        figure1.push([x1, y1])
      }
      return figure1
    }

    const drawSquare = async function(vertices) {
      const a = vertices[0]
      const b = vertices[1]
      const c = vertices[2]
      const d = vertices[3]


      const linesPromises = [
        twoPointLine(a, b),
        twoPointLine(a, c),
        twoPointLine(b, d),
        twoPointLine(c, d)
      ];
      const lines = await Promise.all(linesPromises);


      const drawsPromises = []
      for (line of lines) {
        drawsPromises.push(drawPoints(line))
      }

      await Promise.all(drawsPromises)
    }

    const oneDegree = (Math.PI / 180)


    let frame = 0
    let rotatedVertices = VERTICES
    const animate = async function() {
      const id = setInterval(async function() {
        if (frame > 359) {
          frame = 0
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        await drawSquare(rotatedVertices);
        rotatedVertices = []
        rotatedVertices = await rotationMatrix2D(VERTICES, CENTER, frame * oneDegree)
        frame++
      }, 1000 / 60)
    }
    animate()
  </script>
</body>

</html>